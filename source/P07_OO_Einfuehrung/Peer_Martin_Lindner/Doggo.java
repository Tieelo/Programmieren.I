package P07_OO_Einfuehrung.Peer_Martin_Lindner;

import java.lang.reflect.Field;

public class Doggo
{
    private int    age;
    private String breed;
    private String name;
    private String colour;
    private String size;

    public Doggo(int pAge, String pBreed, String pName, String pColour, String pSize)
    {
        this.age = pAge;
        this.breed = pBreed;
        this.name = pName;
        this.colour = pColour; // blimey, it's a limey
        this.size = pSize;
    }

    // important Doggo methods - not technically but for fun --------
    public void bark()
    {
        System.out.println("Woof, woof!");
    }

    public void callToBrethrenAndSistren()
    {
        System.out.println("ArrooooOOOOOOHHH!");
        // for reference: https://twitter.com/108/status/1285757403179429893 (not that I'm on twatter but t. r. is)
    }

    public String whoIsAGoodBoyOrGirl()
    {
        return this.getName();
    }

    public void eat()
    {
        System.out.println("Chomp, chomp.");
    }

    public void sip()
    {
        System.out.println("Slurp, slurp.");
    }

    public void nap()
    {
        System.out.println("Snore.");
    }

    public void poo()
    {
        System.out.println("Eeeew, that smelly smell. Who dunnit? " + this.getName() + " did it. Tsk, tsk.");
    }

    public void pee()
    {
        System.out.println("Ok, " + this.getName() + " it's time again. Let's go for a little walk.");
    }


    // Now this will come in handy in a pinch if I don't know the class source code ;)
    // courtesy: https://stackoverflow.com/questions/3217603/how-to-print-values-of-an-object-in-java-when-you-do-not-have-the-source-code-for
    // I put the loop into a method inside the class I want to print so I don't need to call field.setAccessible(true).
    // This would work with any class from outside the class. But it also feels quite wrong because it kinda circumvents encapsulation.
    public void printDoggo(Doggo dog)
    {
        for (Field field : dog.getClass().getDeclaredFields()) {
            //field.setAccessible(true); // not needed because we're inside the class left it there anyway for later reference
            String name  = field.getName();
            Object value = null;
            try {
                value = field.get(dog);
                // field.get() might throw an exception so the IDE suggested surrounding it with a try catch block
                // which wasn't in the original snippet but who am I to disagree ;-)
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            }
            System.out.printf("%s: %s%n", name, value);
        }
    }

    // as explained by Mr. Mauer. This can be auto-generated by the IDE and it does not possibly mess with encapsulation.
    // I'm keeping the printDoggo() method anyway, but I'm using the customized toString() as generated by the IDE in main().
    @Override
    public String toString()
    {
        return "Doggo{" +
                "age=" + age +
                ", breed='" + breed + '\'' +
                ", name='" + name + '\'' +
                ", colour='" + colour + '\'' +
                ", size='" + size + '\'' +
                '}';
    }

    /* not fully implemented - this version of the Doggo class is suitable for minors ;)

    public Doggo breed(Doggo male, Doggo female)
    {
        // TODO: Add attribute sex to Doggo class
        // TODO: Add conditional here. Rainbow dogs can mate but they can't make little puppies. ¯\_(ツ)_/¯
        // TODO: Also, dogs usually have more than one puppies in a litter.
        String puppySize = "";

        System.out.println(
                male.getName() + " and " + female.getName() + " meet on a sunny meadow. One thing leads to another and soon...");

        Random myRng  = new Random();
        int    rndNum = myRng.nextInt(1, 3);

        if (rndNum == 1) {
            puppySize = female.getSize();
        } else if (rndNum == 2) {
            puppySize = male.getSize();
        }

        // TODO: can't create more than one new Doggo instances with the same variable name so implement some rng and unique variable name creation for the instance.
        Doggo CutePuppy = new Doggo(
                0,
                (female.getBreed().equals(male.getBreed())) ? female.getBreed() : female.getBreed() + male.getBreed(),
                "Cute Puppy",
                (female.getColour()
                       .equals(male.getColour())) ? female.getColour() : (female.getColour() + male.getColour()),
                puppySize);
        return CutePuppy;
        // remember to set a proper name in main()
    }
    */

    // Auto-generated getters & setters -----------------------------
    public int getAge()
    {
        return age;
    }

    public void setAge(int age)
    {
        this.age = age;
    }

    public String getBreed()
    {
        return breed;
    }

    public void setBreed(String breed)
    {
        this.breed = breed;
    }

    public String getColour()
    {
        return colour;
    }

    public void setColour(String colour)
    {
        this.colour = colour;
    }

    public String getSize()
    {
        return size;
    }

    public void setSize(String size)
    {
        this.size = size;
    }

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}
